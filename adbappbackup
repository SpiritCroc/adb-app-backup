#!/usr/bin/env python3

import argparse
import os
import pickle
import subprocess
import sys

backup_base_path = "~/.adbappbackup"
# TODO
backup_path = "~/.adbappbackup"
#backup_path = None

is_adb_root = False
device_appdata_list = None
device_data_list = None
device_tmp_dir_created = False
local_appdata_list = None
local_data_list = None

adb_device = None
adb_transport_id = None

class PackageInfo:
    def __init__(self, package):
        self.package = package
    def collect(self):
        self.apks = adb(["shell", "cmd", "package", "path", self.package]).decode().split("\n")
    def get_apks(self, base_dir):
        apks = []
        for apk in self.apks:
            if apk.startswith("package:"):
                apks.append("{}/{}".format(base_dir, apk[len("package:"):]))
        return apks

def prepare_backup_base_path(base_path):
    global backup_base_path
    # TODO + use
    backup_base_path = base_path

def run_cmd(cmd):
    debug_out = ">"
    for c in cmd:
        debug_out += " " + c
    print(debug_out)
    return subprocess.check_output(cmd)

def load_adb_device():
    global adb_device, adb_transport_id
    if adb_transport_id != None:
        return
    devices = run_cmd(["adb", "devices", "-l"]).decode().split("\n")
    available = []
    def get_attr(line, attr):
        start_index = line.index(attr + ":") + len(attr) + 1
        try:
            end_index = line.index(" ", start_index)
        except:
            end_index = None
        return line[start_index : end_index]
    for device in devices:
        if "List of devices attached" in device:
            continue
        try:
            a = dict()
            a["serial"] = device[0:device.index(" ")]
            a["product"] = get_attr(device, "product")
            a["model"] = get_attr(device, "model")
            a["transport_id"] = get_attr(device, "transport_id")
            if adb_device == None or adb_device == serial:
                available.append(a)
        except:
            pass
    if len(available) == 0:
        print("No device connected to adb")
        sys.exit(1)
    if len(available) == 1:
        adb_transport_id = available[0]["transport_id"]
        return
    selection = None
    while selection == None:
        for i in range(0, len(available)):
            print("{} {} ({})".format(i+1, available[i]["model"], available[i]["product"]))
        user_in = input("Select device (1-{}): ".format(len(available)))
        try:
            user_in = int(user_in)
            if user_in > 0 and user_in <= len(available):
                selection = user_in - 1
        except:
            pass
    adb_transport_id = available[selection]["transport_id"]

def adb(cmd):
    global adb_transport_id
    if not isinstance(cmd, list):
        cmd = [cmd]
    if adb_transport_id == None:
        load_adb_device()
    return run_cmd(["adb", "-t", adb_transport_id] + cmd)

def adb_pull(target):
    global backup_path
    # TODO: backup path: include device ID and timestamp?
    out = "{}/{}".format(backup_path, os.path.dirname(target))
    run_cmd(["mkdir", "-p", out])
    adb(["pull", target, out])

def adb_push(local_target):
    target = remote_file_from_backup_file(local_target)
    adb(["push", target, "/{}".format(target)])

def get_device_tmp_dir():
    global device_tmp_dir_created
    device_tmp_dir = "/sdcard/.adbappbackup"
    if not device_tmp_dir_created:
        adb(["shell", "mkdir", "-p", device_tmp_dir])
        device_tmp_dir_created = True
    return device_tmp_dir

def remote_file_from_backup_file(local_target):
    global backup_path
    if not local_target.startswith(backup_path):
        raise Exception("Internal error")
    return local_target[len(backup_path):]

def adb_push_indirect(local_target):
    target = remote_file_from_backup_file(local_target)
    device_tmp_dir = get_device_tmp_dir()
    target_base = os.path.basename(target)
    target_dir = os.path.dirname(target)
    # TODO clean up device_tmp_dir?
    adb(["push", local_target, device_tmp_dir])
    adb(["shell", "mv", "{}/{}".format(device_tmp_dir, target_base), target_dir])

def permission_ensure():
    global is_adb_root
    if not is_adb_root:
        adb("root")
        is_adb_root = True

def adb_list_dir(path):
    # ls would work too, but find is more flexible and returns absolute paths
    return adb(["shell", "find", path, "-maxdepth", "1", "-mindepth", "1"]).decode().split("\n")

def local_list_dir(path):
    # ls would work too, but find is more flexible and returns absolute paths
    return run_cmd(["find", path, "-maxdepth", "1", "-mindepth", "1"]).decode().split("\n")

def get_device_appdata_list():
    global device_appdata_list
    if device_appdata_list == None:
        device_appdata_list = adb_list_dir("/data/app/")
    return device_appdata_list

def get_local_appdata_list():
    global local_appdata_list, backup_path
    if local_appdata_list == None:
        local_appdata_list = local_list_dir("{}/data/app".format(backup_path))
    return local_appdata_list

def get_appdata(appdata_list, package):
    for appdata in appdata_list:
        if os.path.basename(appdata).startswith("{}-".format(package)):
            return appdata
    raise Exception("No app data found for {}".format(package))

def get_device_data_list():
    global device_data_list
    if device_data_list == None:
        device_data_list = adb_list_dir("/data/data/")
    return device_data_list

def get_local_data_list():
    global local_data_list, backup_path
    if local_data_list == None:
        local_data_list = local_list_dir("{}/data/data".format(backup_path))
    return local_data_list

def get_data(data_list, package):
    for data in data_list:
        if os.path.basename(data) == package:
            return data
    raise Exception("No data found for {}".format(package))

def get_app_uid(package):
    dumpsys = adb(["shell", "dumpsys", "package", package]).decode()
    for line in dumpsys.split('\n'):
        if "userId=" in line:
            return int(line[line.index("=")+1:])

def backup_app(packages):
    global backup_path
    # TODO versionize backups
    permission_ensure()
    appdata_list = get_device_appdata_list()
    data_list = get_device_data_list()
    for package in packages:
        package_info = PackageInfo(package)
        package_info.collect()
        appdata = get_appdata(appdata_list, package)
        data = get_data(data_list, package)
        adb_pull(data)
        adb_pull(appdata)
        with open("{}/package_info".format(backup_path), "wb") as pif:
            pickle.dump(package_info, pif)

def restore_app(packages):
    global backup_path
    permission_ensure()
    appdata_list = get_local_appdata_list()
    data_list = get_local_data_list()
    for package in packages:
        with open("{}/package_info".format(backup_path), "rb") as pif:
            package_info = pickle.load(pif)
        appdata = get_appdata(appdata_list, package)
        data = get_data(data_list, package)
        # TODO uninstall if already exists to make sure we don't have any conflicting data
        adb(["install-multiple", "-t"] + package_info.get_apks(backup_path))
        adb_push_indirect(data)
        # Remove cache: might cause troubles and should not be necessary
        remote_data = remote_file_from_backup_file(data)
        try:
            adb(["shell", "rm", "-r", "{}/cache".format(remote_data)])
        except subprocess.CalledProcessError:
            pass
        try:
            adb(["shell", "rm", "-r", "{}/code_cache".format(remote_data)])
        except subprocess.CalledProcessError:
            pass
        # Fix uid
        uid = get_app_uid(package)
        adb(["shell", "chown", "-R", "{}:{}".format(uid, uid), remote_data])

def list_backups():
    print("TODO")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Backup apps + data using adb (root)")
    parser.add_argument("--device", type=str, nargs=1, metavar="SERIAL", help="Device serial (see `adb devices`)")
    parser.add_argument("--backup_path", type=str, nargs=1, default=[backup_path])
    parser.add_argument("--backup", action='store_const', const=True, default=False)
    parser.add_argument("--restore", action='store_const', const=True, default=False)
    parser.add_argument("package", type=str, nargs='*')
    args = parser.parse_args()
    backup_path = os.path.expanduser(args.backup_path[0])
    done_anything = False
    if args.device != None:
        adb_device = args.device[0]
    if args.backup:
        backup_app(args.package)
        done_anything = True
    if args.restore:
        restore_app(args.package)
        done_anything = True
    if not done_anything:
        list_backups()
