#!/usr/bin/env python3

import argparse
import os
import pickle
import subprocess
import sys
import traceback
import time

from datetime import datetime

backup_base_path = "~/.adbappbackup"

is_adb_root = False
device_appdata_list = None
device_data_list = None
device_tmp_dir_created = False

adb_device = None
adb_transport_id = None

class PackageInfo:
    def __init__(self, package):
        self.package = package
    def collect(self):
        self.apks = adb(["shell", "cmd", "package", "path", self.package]).decode().split("\n")
    def get_apks(self, base_dir):
        apks = []
        for apk in self.apks:
            if apk.startswith("package:"):
                apks.append("{}/{}".format(base_dir, apk[len("package:"):]))
        return apks

def get_effective_device(device):
    global adb_device
    if adb_device == None:
        load_adb_device()
    if device == None:
        device = adb_device
    if device == None:
        raise Exception("Internal error")
    return device

def get_backup_device_path(device = None, offline = False):
    global backup_base_path
    if not offline:
        device = get_effective_device(device)
    return "{}/{}".format(backup_base_path, device)

def get_backed_up_devices():
    global backup_base_path
    try:
        return sorted(os.listdir(backup_base_path))
    except FileNotFoundError:
        return []

def get_backed_up_packages(device):
    backup_device_path = get_backup_device_path(device, offline = True)
    try:
        return sorted(os.listdir(backup_device_path))
    except FileNotFoundError:
        return []

def get_backup_revisions(device, package, offline = False):
    backup_path = get_backup_path(package, device, offline = offline)
    try:
        return sorted(os.listdir(backup_path))
    except FileNotFoundError:
        return []

def get_backup_path(package, device = None, offline = False):
    return "{}/{}".format(get_backup_device_path(device, offline = offline), package)

def select_backup_revision_path(package, device = None):
    backup_path = get_backup_path(package, device)
    paths = get_backup_revisions(device, package)
    if len(paths) == 0:
        print("No backup found for package \"{}\" and device \"{}\"".format(package, get_effective_device(device)))
        sys.exit(1)
    if len(paths) == 1:
        selection = 0
    else:
        selection = None
        while selection == None:
            print("Available backups for {}:".format(package))
            for i in range(0, len(paths)):
                print("{} {}".format(i+1, paths[i]))
            user_in = input("Select backup (1-{}): ".format(len(paths)))
            try:
                user_in = int(user_in)
                if user_in > 0 and user_in <= len(paths):
                    selection = user_in - 1
            except:
                pass
    return "{}/{}".format(backup_path, paths[selection])

def latest_backup_revision_path(package, device = None):
    backup_path = get_backup_path(package, device)
    # revisions are sorted
    paths = get_backup_revisions(device, package)
    if len(paths) == 0:
        print("No backup found for package \"{}\" and device \"{}\"".format(package, get_effective_device(device)))
        sys.exit(1)
    return "{}/{}".format(backup_path, paths[-1])

def get_new_backup_revision_path(package):
    backup_path = get_backup_path(package)
    timeid = datetime.now().strftime("%Y%m%d_%H%M%S")
    return "{}/{}".format(backup_path, timeid)

def run_cmd(cmd):
    debug_out = ">"
    for c in cmd:
        debug_out += " " + c
    print(debug_out, file=sys.stderr)
    return subprocess.check_output(cmd)

def load_adb_device():
    global adb_device, adb_transport_id
    if adb_transport_id != None:
        return
    devices = run_cmd(["adb", "devices", "-l"]).decode().split("\n")
    available = []
    def get_attr(line, attr):
        start_index = line.index(attr + ":") + len(attr) + 1
        try:
            end_index = line.index(" ", start_index)
        except:
            end_index = None
        return line[start_index : end_index]
    for device in devices:
        if "List of devices attached" in device:
            continue
        try:
            a = dict()
            a["serial"] = device[0:device.index(" ")]
            a["product"] = get_attr(device, "product")
            a["model"] = get_attr(device, "model")
            a["transport_id"] = get_attr(device, "transport_id")
            if adb_device == None or adb_device == a["serial"]:
                available.append(a)
        except:
            pass
    if len(available) == 0:
        raise Exception("No device connected to adb")
    if len(available) == 1:
        selection = 0
    else:
        selection = None
        while selection == None:
            for i in range(0, len(available)):
                print("{} {} ({})".format(i+1, available[i]["model"], available[i]["product"]))
            user_in = input("Select device (1-{}): ".format(len(available)))
            try:
                user_in = int(user_in)
                if user_in > 0 and user_in <= len(available):
                    selection = user_in - 1
            except:
                pass
    adb_transport_id = available[selection]["transport_id"]
    if adb_transport_id == None:
        raise Exception("Could not get adb transport id")
    adb_device = available[selection]["serial"]
    if adb_device == None:
        raise Exception("Could not get adb device serial")

def adb(cmd):
    global adb_transport_id
    if not isinstance(cmd, list):
        cmd = [cmd]
    if adb_transport_id == None:
        load_adb_device()
    return run_cmd(["adb", "-t", adb_transport_id] + cmd)

def adb_pull(target, backup_path):
    out = "{}/{}".format(backup_path, os.path.dirname(target))
    run_cmd(["mkdir", "-p", out])
    adb(["pull", target, out])

def adb_push(local_target, backup_path):
    target = remote_file_from_backup_file(local_target, backup_path)
    adb(["push", target, "/{}".format(target)])

def get_device_tmp_dir():
    global device_tmp_dir_created
    device_tmp_dir = "/sdcard/.adbappbackup"
    if not device_tmp_dir_created:
        adb(["shell", "mkdir", "-p", device_tmp_dir])
        device_tmp_dir_created = True
    return device_tmp_dir

def remote_file_from_backup_file(local_target, backup_path):
    if not local_target.startswith(backup_path):
        raise Exception("Internal error")
    return local_target[len(backup_path):]

def adb_push_indirect(local_target, backup_path):
    target = remote_file_from_backup_file(local_target, backup_path)
    device_tmp_dir = get_device_tmp_dir()
    target_base = os.path.basename(target)
    target_dir = os.path.dirname(target)
    # TODO clean up device_tmp_dir?
    adb(["push", local_target, device_tmp_dir])
    adb(["shell", "mv", "{}/{}".format(device_tmp_dir, target_base), target_dir])

def permission_ensure():
    global is_adb_root, adb_transport_id
    if not is_adb_root:
        adb("root")
        is_adb_root = True
        # Reload transport id
        adb_transport_id = None
        # adb devices -l might not see our device immediately
        for i in range(0, 10):
            time.sleep(1)
            try:
                load_adb_device()
                break
            except:
                pass
        if adb_transport_id == None:
            # One final try
            load_adb_device()

def adb_list_dir(path):
    # ls would work too, but find is more flexible and returns absolute paths
    return adb(["shell", "find", path, "-maxdepth", "1", "-mindepth", "1"]).decode().split("\n")

def local_list_dir(path):
    # ls would work too, but find is more flexible and returns absolute paths
    return run_cmd(["find", path, "-maxdepth", "1", "-mindepth", "1"]).decode().split("\n")

def get_device_appdata_list():
    global device_appdata_list
    if device_appdata_list == None:
        device_appdata_list = adb_list_dir("/data/app/")
    return device_appdata_list

def get_local_appdata_list(backup_path):
    return local_list_dir("{}/data/app".format(backup_path))

def get_package_from_appdata(appdata):
    appdata = os.path.basename(appdata)
    return appdata[0:appdata.index("-")]

def get_appdata(appdata_list, package):
    for appdata in appdata_list:
        if os.path.basename(appdata).startswith("{}-".format(package)):
            return appdata
    raise Exception("No app data found for {}".format(package))

def get_device_data_list():
    global device_data_list
    if device_data_list == None:
        device_data_list = adb_list_dir("/data/data/")
    return device_data_list

def get_local_data_list(backup_path):
    return local_list_dir("{}/data/data".format(backup_path))

def get_data(data_list, package):
    for data in data_list:
        if os.path.basename(data) == package:
            return data
    raise Exception("No data found for {}".format(package))

def get_app_uid(package):
    dumpsys = adb(["shell", "dumpsys", "package", package]).decode()
    for line in dumpsys.split('\n'):
        if "userId=" in line:
            return int(line[line.index("=")+1:])

def get_installed_packages():
    # That's not all installed packages, but those that we support backin up right now
    appdata_list = get_device_appdata_list()
    result = []
    for appdata in appdata_list:
        if appdata != "":
            result.append(get_package_from_appdata(appdata))
    return result

def backup_app(packages):
    permission_ensure()
    appdata_list = get_device_appdata_list()
    data_list = get_device_data_list()
    for package in packages:
        try:
            backup_path = get_new_backup_revision_path(package)
            package_info = PackageInfo(package)
            package_info.collect()
            appdata = get_appdata(appdata_list, package)
            data = get_data(data_list, package)
            adb_pull(data, backup_path)
            adb_pull(appdata, backup_path)
            with open("{}/package_info".format(backup_path), "wb") as pif:
                pickle.dump(package_info, pif)
        except:
            print("Backup of {} failed".format(packages), file=sys.stderr)
            traceback.print_exc()

def restore_app(packages, backup_device = None, latest = False):
    permission_ensure()
    for package in packages:
        try:
            if latest:
                backup_path = latest_backup_revision_path(package, backup_device)
            else:
                backup_path = select_backup_revision_path(package, backup_device)
            appdata_list = get_local_appdata_list(backup_path)
            data_list = get_local_data_list(backup_path)
            with open("{}/package_info".format(backup_path), "rb") as pif:
                package_info = pickle.load(pif)
            appdata = get_appdata(appdata_list, package)
            data = get_data(data_list, package)
            # TODO uninstall if already exists to make sure we don't have any conflicting data
            adb(["install-multiple", "-t"] + package_info.get_apks(backup_path))
            adb_push_indirect(data, backup_path)
            # Remove cache: might cause troubles and should not be necessary
            remote_data = remote_file_from_backup_file(data, backup_path)
            try:
                adb(["shell", "rm", "-r", "{}/cache".format(remote_data)])
            except subprocess.CalledProcessError:
                pass
            try:
                adb(["shell", "rm", "-r", "{}/code_cache".format(remote_data)])
            except subprocess.CalledProcessError:
                pass
            # Fix uid
            uid = get_app_uid(package)
            adb(["shell", "chown", "-R", "{}:{}".format(uid, uid), remote_data])
        except:
            print("Restore of {} failed".format(packages), file=sys.stderr)
            traceback.print_exc()

def list_backups_for_device(device, packages):
    available_packages = get_backed_up_packages(device)
    if len(available_packages) == 0:
        print("No backups yet")
        return
    for package in available_packages:
        if len(packages) > 0 and not package in packages:
            continue
        print(package)
        revisions = get_backup_revisions(device, package, offline = True)
        for revision in revisions:
            print("- {}".format(revision))

def list_installed_packages():
    permission_ensure()
    packages = get_installed_packages()
    for package in sorted(packages):
        print(package)

def list_backups(device = None, packages = []):
    if device != None:
        list_backups_for_device(device, packages)
        return
    devices = get_backed_up_devices()
    if len(devices) == 0:
        print("No backups yet")
        return
    for device in devices:
        print("Backups for device {}".format(device))
        list_backups_for_device(device, packages)
        print()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Backup apps + data using adb (root)")
    parser.add_argument("--device", type=str, nargs=1, metavar="SERIAL", help="Device serial (see `adb devices`)", default=[None])
    parser.add_argument("--backup_device", type=str, nargs=1, metavar="SERIAL", help="Device serial for the backup. Set if you want to restore a backup from a different device", default=[None])
    parser.add_argument("--backup_path", type=str, nargs=1, default=[backup_base_path])
    parser.add_argument("--backup", action='store_const', const=True, default=False)
    parser.add_argument("--restore", action='store_const', const=True, default=False)
    parser.add_argument("--latest", action='store_const', const=True, default=False, help="Automatically use the latest backup")
    parser.add_argument("--list_packages", action='store_const', const=True, default=False, help="Output a list of installed packages available for backup. Can be used to create lists for --package_list")
    parser.add_argument("--package_list", metavar="FILE", type=str, nargs=1, default=[None], help="Read packages from FILE")
    parser.add_argument("package", type=str, nargs='*')
    args = parser.parse_args()
    backup_base_path = os.path.expanduser(args.backup_path[0])
    done_anything = False
    if args.device[0] != None:
        adb_device = args.device[0]

    if args.package_list[0] != None:
        with open(os.path.expanduser(args.package_list[0]), "r") as infile:
            for package in infile.read().split("\n"):
                if len(package) == 0:
                    continue
                if package[-1] == '\r':
                    package = package[0:-1]
                if len(package) == 0:
                    continue
                args.package.append(package)

    # Backup
    if args.backup:
        backup_app(args.package)
        done_anything = True

    # Restore
    if args.restore:
        restore_app(args.package, args.backup_device[0], latest=args.latest)
        done_anything = True

    if args.list_packages:
        list_installed_packages()
        done_anything = True

    # List
    if not done_anything:
        list_backups(args.device[0] if args.backup_device[0] == None else args.backup_device[0], args.package)
