#!/usr/bin/env python3

import argparse
import os
import pickle
import subprocess

backup_path = "~/.adbappbackup"

is_adb_root = False
device_appdata_list = None
device_data_list = None
local_appdata_list = None
local_data_list = None

# TODO: if more than one device: prompt selection; if not: remember device id in case this changes
adb_device = None

class PackageInfo:
    def __init__(self, package):
        self.package = package
    def collect(self):
        self.apks = adb(["shell", "cmd", "package", "path", self.package]).decode().split("\n")
    def get_apks(self, base_dir):
        apks = []
        for apk in self.apks:
            if apk.startswith("package:"):
                apks.append("{}/{}".format(base_dir, apk[len("package:"):]))
        return apks

def run_cmd(cmd):
    debug_out = ">"
    for c in cmd:
        debug_out += " " + c
    print(debug_out)
    return subprocess.check_output(cmd)

def adb(cmd):
    global adb_device
    if not isinstance(cmd, list):
        cmd = [cmd]
    if adb_device != None:
        cmd = ["-s", adb_device] + cmd
    return run_cmd(["adb"] + cmd)

def adb_pull(target):
    global backup_path
    # TODO: backup path: include device ID and timestamp?
    out = "{}/{}".format(backup_path, os.path.dirname(target))
    run_cmd(["mkdir", "-p", out])
    adb(["pull"] + [target, out])

def adb_push(target):
    global backup_path
    if not target.startswith(backup_path):
        raise Exception("Internal error")
    adb(["push"] + [target, "/{}".format(target[len(backup_path):])])

def permission_ensure():
    global is_adb_root
    if not is_adb_root:
        adb("root")
        is_adb_root = True

def adb_list_dir(path):
    # ls would work too, but find is more flexible and returns absolute paths
    return adb(["shell", "find", path, "-maxdepth", "1", "-mindepth", "1"]).decode().split("\n")

def local_list_dir(path):
    # ls would work too, but find is more flexible and returns absolute paths
    return run_cmd(["find", path, "-maxdepth", "1", "-mindepth", "1"]).decode().split("\n")

def get_device_appdata_list():
    global device_appdata_list
    if device_appdata_list == None:
        device_appdata_list = adb_list_dir("/data/app/")
    return device_appdata_list

def get_local_appdata_list():
    global local_appdata_list, backup_path
    if local_appdata_list == None:
        local_appdata_list = local_list_dir("{}/data/app".format(backup_path))
    return local_appdata_list

def get_appdata(appdata_list, package):
    for appdata in appdata_list:
        if os.path.basename(appdata).startswith("{}-".format(package)):
            return appdata
    raise Exception("No app data found for {}".format(package))

def get_device_data_list():
    global device_data_list
    if device_data_list == None:
        device_data_list = adb_list_dir("/data/data/")
    return device_data_list

def get_local_data_list():
    global local_data_list, backup_path
    if local_data_list == None:
        local_data_list = local_list_dir("{}/data/data".format(backup_path))
    return local_data_list

def get_data(data_list, package):
    for data in data_list:
        if os.path.basename(data) == package:
            return data
    raise Exception("No data found for {}".format(package))

def backup_app(packages):
    global backup_path
    # TODO versionize backups
    permission_ensure()
    appdata_list = get_device_appdata_list()
    data_list = get_device_data_list()
    for package in packages:
        package_info = PackageInfo(package)
        package_info.collect()
        appdata = get_appdata(appdata_list, package)
        data = get_data(data_list, package)
        adb_pull(data)
        adb_pull(appdata)
        with open("{}/package_info".format(backup_path), "wb") as pif:
            pickle.dump(package_info, pif)

def restore_app(packages):
    global backup_path
    permission_ensure()
    appdata_list = get_local_appdata_list()
    data_list = get_local_data_list()
    for package in packages:
        with open("{}/package_info".format(backup_path), "rb") as pif:
            package_info = pickle.load(pif)
        appdata = get_appdata(appdata_list, package)
        data = get_data(data_list, package)
        # TODO uninstall if already exists to make sure we don't have any conflicting data
        adb(["install-multiple", "-t"] + package_info.get_apks(backup_path))
        adb_push(data)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Backup apps + data using adb (root)")
    parser.add_argument("--device", type=str, nargs=1, metavar="SERIAL", help="Device serial (see `adb devices`)")
    parser.add_argument("--backup_path", type=str, nargs=1, default=[backup_path])
    parser.add_argument("--backup", action='store_const', const=True, default=False)
    parser.add_argument("--restore", action='store_const', const=True, default=False)
    parser.add_argument("package", type=str, nargs='+')
    args = parser.parse_args()
    backup_path = os.path.expanduser(args.backup_path[0])
    done_anything = False
    if args.device != None:
        adb_device = args.device[0]
    if args.backup:
        backup_app(args.package)
        done_anything = True
    if args.restore:
        restore_app(args.package)
        done_anything = True
    if not done_anything:
        parser.print_help()
